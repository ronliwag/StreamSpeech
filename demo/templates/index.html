<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamSpeech</title>
    <script src="https://unpkg.com/wavesurfer.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1400px; /* Increased the width */
            margin: 0 auto;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #000000;
        }
        p {
            text-align: center;
        }
        .badges {
            text-align: center;
            margin: 15px 0; /* Reduced the margin */
        }
        form {
            display: flex;
            justify-content: center;
            margin-bottom: 10px; /* Reduced the margin */
        }
        input[type="file"] {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px; /* Reduced the padding */
            cursor: pointer;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px; /* Reduced the padding */
            cursor: pointer;
            margin-left: 10px;
        }
        button:disabled {
            background-color: #ddd;
            cursor: not-allowed;
        }
        button:hover:not([disabled]) {
            background-color: #45a049;
        }
        #playOriginalButton {
            background-color: #ffa500;
            padding: 8px 16px;
        }
        #playOriginalButton:hover:not([disabled]) {
            background-color: #cc8400;
        }
        #playModifiedButton {
            background-color: #800080;
            padding: 8px 16px;
        }
        #playModifiedButton:hover:not([disabled]) {
            background-color: #600060;
        }
        #playBothButton {
            background-color: #70b027;
            padding: 8px 16px;
        }
        #playBothButton:hover:not([disabled]) {
            background-color: #5a8d1f;
        }
        #playSourceOriginalButton {
            background-color: #ffa500;
            padding: 8px 16px;
        }
        #playSourceOriginalButton:hover:not([disabled]) {
            background-color: #cc8400;
        }
        #playSourceModifiedButton {
            background-color: #800080;
            padding: 8px 16px;
        }
        #playSourceModifiedButton:hover:not([disabled]) {
            background-color: #600060;
        }
        #playSourceButton {
            background-color: blue;
            padding: 8px 16px;
        }
        #playSourceButton:hover:not([disabled]) {
            background-color: #0000cc;
        }
        #waveform, #outputWaveform, #outputWaveformModified {
            margin: 10px 0; /* Reduced the margin */
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .results {
            margin-top: 10px; /* Reduced the margin */
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        h2, .result-title {
            font-size: 16px;
            color: #000000;
            align-items: center;
            margin: 5px 0; /* Reduced the margin */
        }
        .result-content {
            font-size: 16px;
            color: #001eff;
            margin-left: 10px;
            white-space: pre-wrap; /* Preserve empty lines */
            min-height: 1em; /* Ensure at least one line of height */
        }
        .result-content2 {
            font-size: 16px;
            color: #ff8800;
            margin-left: 10px;
            white-space: pre-wrap; /* Preserve empty lines */
            min-height: 1em; /* Ensure at least one line of height */
        }
        .streaming-inputs {
            margin-top: 10px; /* Reduced the margin */
            padding: 10px;
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .wave-progress {
            width: 10px; /* Adjust the height for the progress line width */
        }
        .tag-sticker {
        position: absolute;
        font-size: 16px;
        top: 0px; /* Adjusted top position to be above the title */
        left: 5px; /* Adjusted left position to align with the title */
        transform: rotate(-15deg);
        background-color: #ff5722;
        color: white;
        padding: 5px 5px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .title-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0; /* Reduce the margin-bottom to minimize space */
        }
        h1 {
            margin-bottom: -5px; /* Reduced the margin-bottom of the title */
            color: #000000;
        }
        h4{
            font-size: 18px;
            color: #000000;
            margin: 3px 0; /* Reduced the margin */
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-right: 10px;
            position: relative;
        }
        .slider-container label {
            margin-right: 10px;
        }
        #latencySlider {
            margin-right: 10px;
        }
        #latencyValueBox {
            display: inline-block;
            width: 50px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 3px;
            background-color: #fff;
        }
    </style>
    
</head>
<body>
    <div class="container">
        <div class="title-container">
            <div class="tag-sticker"> MODIFIED </div>
            <h1>StreamSpeech: Simultaneous Speech-to-Speech Translation with Multi-task Learning</h1>
        </div>
        <br>
        <form id="uploadForm">
            <div class="slider-container">
                <label for="latencySlider">Latency (ms): </label>
                <input type="range" id="latencySlider" name="latency" min="320" max="5000" value="320" step="10" oninput="updateLatencyLabel(this)">
                <div id="latencyValueBox">320</div>
            </div>
            <input type="file" id="fileInput" name="file" required>
            <button type="submit" id="uploadButton" disabled>Upload</button>
        </form>
        <div class="streaming-inputs">
            <h2>Source Audio (Spanish)</h2>
            <div id="waveform"></div>
            <div style="margin-top: 10px;">
                <button id="playSourceButton" disabled style="background-color: blue; padding: 8px 16px;">▶ Play Source</button>
                <button id="playBothButton" disabled style="background-color: #70b027; padding: 8px 16px; margin-left: 10px;">▶ Play Both Outputs</button>
                <button id="playSourceOriginalButton" disabled style="background-color: #ffa500; padding: 8px 16px; margin-left: 10px;">▶ Play Source + Original</button>
                <button id="playSourceModifiedButton" disabled style="background-color: #800080; padding: 8px 16px; margin-left: 10px;">▶ Play Source + Modified</button>
            </div>
        </div>
        <div class="results">
            <h2 class="result-title">Streaming Speech Recognition<br></h2>
            <div id="asrResult" class="result-content"><br></div> <!-- Ensure empty line initially -->
        </div>
        <div class="results">
            <h2 class="result-title">Simultaneous Speech-to-Text Translation</h2>
            <div id="translationResult" class="result-content2"><br></div> <!-- Ensure empty line initially -->
        </div>
        <div class="results">
            <h2 class="result-title">Output: Original Vocoder (Standard English)</h2>
            <div id="outputWaveform"></div>
            <button id="playOriginalButton" disabled style="background-color: #ffa500; margin-top: 10px;">▶ Play Original Vocoder</button>
        </div>
        <div class="results" id="modifiedVocoderSection">
            <h2 class="result-title">Output: Modified Vocoder (Voice Transfer - English with Spanish Voice)</h2>
            <div id="outputWaveformModified"></div>
            <button id="playModifiedButton" disabled style="background-color: #800080; margin-top: 10px;">▶ Play Modified Vocoder</button>
        </div>
    </div>

    <script>
        // Create AudioContext with explicit 16kHz sample rate to match server output
        // This prevents browser from using default 48kHz which causes 3x speed-up
        var audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000  // CRITICAL: Match the server's SAMPLE_RATE
            });
            console.log('AudioContext created at ' + audioContext.sampleRate + ' Hz');
        } catch (e) {
            console.error('Failed to create AudioContext with 16kHz:', e);
            // Fallback to default context (may cause speed issues)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.warn('Using default AudioContext at ' + audioContext.sampleRate + ' Hz - audio may be sped up');
        }
        
        var inputWaveSurfer, outputWaveSurfer, outputWaveSurferModified;
        var asrInterval, translationInterval;
        var currentFilename = null;
        var currentLatency = 320;
        var playSourceButton = document.getElementById('playSourceButton');
        var playOriginalButton = document.getElementById('playOriginalButton');
        var playModifiedButton = document.getElementById('playModifiedButton');
        var playBothButton = document.getElementById('playBothButton');
        var playSourceOriginalButton = document.getElementById('playSourceOriginalButton');
        var playSourceModifiedButton = document.getElementById('playSourceModifiedButton');
        var lastPlaybackTime = 0;
        var stuckCounter = 0;

        // Listen for changes in the file input
        document.getElementById('fileInput').addEventListener('change', function() {
            var uploadButton = document.getElementById('uploadButton');
            if (this.files.length > 0) {
                uploadButton.disabled = false;
                uploadButton.style.backgroundColor = '#4CAF50'; // Change color to green
            } else {
                uploadButton.disabled = true;
                uploadButton.style.backgroundColor = '#ddd'; // Change back to gray
            }
        });

        document.getElementById('uploadForm').addEventListener('submit', function(event) {
            event.preventDefault();
            var fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                return;
            }

            var formData = new FormData();
            var file = fileInput.files[0];
            formData.append('file', file);

            var latencySlider = document.getElementById('latencySlider');
            var latency = parseInt(latencySlider.value, 10);
            currentLatency = latency;
            console.log('Latency value selected:', latency, 'ms');

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.text())
            .then(filepath => {
                var filename = filepath.split('/').pop();
                currentFilename = filename;
                startProcessing(currentFilename, latency);
            })
            .catch(error => console.error('Error:', error));
        });

        document.getElementById('latencySlider').addEventListener('change', function() {
            var newLatency = parseInt(this.value, 10);
            updateLatencyLabel(this);
            currentLatency = newLatency;
            if (currentFilename) {
                console.log('Latency slider changed:', newLatency, 'ms - reprocessing current file');
                startProcessing(currentFilename, newLatency);
            }
        });

        function startProcessing(filename, latency) {
            if (!filename) {
                return;
            }

            currentFilename = filename;
            currentLatency = parseInt(latency, 10) || currentLatency || 320;

            refreshResults();

            var slider = document.getElementById('latencySlider');
            if (slider && slider.value !== String(currentLatency)) {
                slider.value = currentLatency;
                updateLatencyLabel(slider);
            }

            inputWaveSurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#ffffff',
                progressColor: 'blue',
                normalize: true,
                progressClass: 'wave-progress',
                interact: false,
                loop: false,
                audioContext: audioContext
            });

            inputWaveSurfer.on('ready', function() {
                fetch('/is_dual_mode')
                    .then(response => response.json())
                    .then(data => {
                        const isDualMode = data.dual_mode;

                        const originalSectionTitle = document.querySelector('.results:nth-of-type(3) .result-title');
                        const cacheTag = Date.now();

                        outputWaveSurfer = WaveSurfer.create({
                            container: '#outputWaveform',
                            waveColor: '#f9f9f9',
                            progressColor: 'orange',
                            normalize: true,
                            loop: false,
                            audioContext: audioContext
                        });

                        if (isDualMode) {
                            if (originalSectionTitle) {
                                originalSectionTitle.innerText = 'Simultaneous Speech-to-Speech Translation (Original Vocoder)';
                            }

                            outputWaveSurfer.load(`/output_original/${filename}?t=${cacheTag}`);

                            outputWaveSurferModified = WaveSurfer.create({
                                container: '#outputWaveformModified',
                                waveColor: '#f9f9f9',
                                progressColor: 'purple',
                                normalize: true,
                                loop: false,
                                audioContext: audioContext
                            });

                            outputWaveSurferModified.load(`/output_modified/${filename}?t=${cacheTag}`);

                            playModifiedButton.disabled = false;
                            playModifiedButton.style.backgroundColor = '#800080';

                            playBothButton.disabled = false;
                            playBothButton.style.backgroundColor = '#70b027';
                            playSourceModifiedButton.disabled = false;
                            playSourceModifiedButton.style.backgroundColor = '#800080';

                            playModifiedButton.removeEventListener('click', playModifiedHandler);
                            playModifiedButton.addEventListener('click', playModifiedHandler);
                            playBothButton.removeEventListener('click', playBothHandler);
                            playBothButton.addEventListener('click', playBothHandler);
                            playSourceModifiedButton.removeEventListener('click', playSourceModifiedHandler);
                            playSourceModifiedButton.addEventListener('click', playSourceModifiedHandler);
                        } else {
                            if (originalSectionTitle) {
                                originalSectionTitle.innerText = 'Output: Original Vocoder (Standard English)';
                            }
                            outputWaveSurfer.load(`/output/${filename}?t=${cacheTag}`);

                            playModifiedButton.disabled = true;
                            playModifiedButton.style.backgroundColor = '#ddd';
                            playBothButton.disabled = true;
                            playBothButton.style.backgroundColor = '#ddd';
                            playSourceModifiedButton.disabled = true;
                            playSourceModifiedButton.style.backgroundColor = '#ddd';

                            playModifiedButton.removeEventListener('click', playModifiedHandler);
                            playBothButton.removeEventListener('click', playBothHandler);
                            playSourceModifiedButton.removeEventListener('click', playSourceModifiedHandler);

                            outputWaveSurferModified = null;
                        }

                        playSourceButton.disabled = false;
                        playSourceButton.style.backgroundColor = 'blue';
                        playOriginalButton.disabled = false;
                        playOriginalButton.style.backgroundColor = '#ffa500';
                        playSourceOriginalButton.disabled = false;
                        playSourceOriginalButton.style.backgroundColor = '#ffa500';

                        playSourceButton.removeEventListener('click', playSourceHandler);
                        playSourceButton.addEventListener('click', playSourceHandler);

                        playOriginalButton.removeEventListener('click', playOriginalHandler);
                        playOriginalButton.addEventListener('click', playOriginalHandler);

                        playSourceOriginalButton.removeEventListener('click', playSourceOriginalHandler);
                        playSourceOriginalButton.addEventListener('click', playSourceOriginalHandler);

                        outputWaveSurfer.on('finish', function() {
                            console.log("Original output finished");
                            playOriginalButton.innerHTML = '▶ Play Original Vocoder';
                            playBothButton.innerHTML = '▶ Play Both Outputs';
                            playSourceOriginalButton.innerHTML = '▶ Play Source + Original';
                            clearInterval(asrInterval);
                            clearInterval(translationInterval);
                            asrInterval = null;
                            translationInterval = null;
                        });

                        outputWaveSurfer.on('pause', function() {
                            console.log("Original output paused");
                            clearInterval(asrInterval);
                            clearInterval(translationInterval);
                            asrInterval = null;
                            translationInterval = null;
                        });

                        if (isDualMode && outputWaveSurferModified) {
                            outputWaveSurferModified.on('finish', function() {
                                console.log("Modified output finished");
                                playModifiedButton.innerHTML = '▶ Play Modified Vocoder';
                                playBothButton.innerHTML = '▶ Play Both Outputs';
                                playSourceModifiedButton.innerHTML = '▶ Play Source + Modified';
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });

                            outputWaveSurferModified.on('pause', function() {
                                console.log("Modified output paused");
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });
                        }

                        inputWaveSurfer.on('pause', function() {
                            console.log("Input paused");
                            clearInterval(asrInterval);
                            clearInterval(translationInterval);
                            asrInterval = null;
                            translationInterval = null;
                        });

                        inputWaveSurfer.on('finish', function() {
                            console.log("Input finished");
                            playSourceButton.innerHTML = '▶ Play Source';
                            playSourceOriginalButton.innerHTML = '▶ Play Source + Original';
                            playSourceModifiedButton.innerHTML = '▶ Play Source + Modified';
                            clearInterval(asrInterval);
                            clearInterval(translationInterval);
                            asrInterval = null;
                            translationInterval = null;
                        });
                    });
            });

            console.log('[INFO] Requesting processing with URL:', `/process/${filename}?latency=${currentLatency}`);
            inputWaveSurfer.load(`/process/${filename}?latency=${currentLatency}&t=${Date.now()}`);
        }

        function refreshResults() {
            document.getElementById('asrResult').innerText = ''; // Clear ASR result and preserve empty line
            document.getElementById('translationResult').innerText = ''; // Clear translation result and preserve empty line
            document.getElementById('outputWaveform').innerHTML = ''; // Clear output waveform
            document.getElementById('outputWaveformModified').innerHTML = ''; // Clear Modified Vocoder output waveform
            document.getElementById('waveform').innerHTML = ''; // Clear input waveform
            if (inputWaveSurfer) {
                inputWaveSurfer.destroy();
                inputWaveSurfer = null;
            }
            if (outputWaveSurfer) {
                outputWaveSurfer.destroy();
                outputWaveSurfer = null;
            }
            if (outputWaveSurferModified) {
                outputWaveSurferModified.destroy();
                outputWaveSurferModified = null;
            }

            var controlDefaults = [
                { button: playSourceButton, label: '▶ Play Source' },
                { button: playOriginalButton, label: '▶ Play Original Vocoder' },
                { button: playModifiedButton, label: '▶ Play Modified Vocoder' },
                { button: playBothButton, label: '▶ Play Both Outputs' },
                { button: playSourceOriginalButton, label: '▶ Play Source + Original' },
                { button: playSourceModifiedButton, label: '▶ Play Source + Modified' }
            ];

            controlDefaults.forEach(function(entry) {
                if (entry.button) {
                    entry.button.disabled = true;
                    entry.button.style.backgroundColor = '#ddd';
                    if (entry.label) {
                        entry.button.innerHTML = entry.label;
                    }
                }
            });
        }

        function playSourceHandler() {
            // Play/pause only the source audio
            if (inputWaveSurfer) {
                if (inputWaveSurfer.isPlaying()) {
                    inputWaveSurfer.pause();
                    playSourceButton.innerHTML = '▶ Play Source';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    inputWaveSurfer.play();
                    playSourceButton.innerHTML = '⏸ Pause Source';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playOriginalHandler() {
            // Play/pause only the original vocoder output
            if (outputWaveSurfer) {
                if (outputWaveSurfer.isPlaying()) {
                    outputWaveSurfer.pause();
                    playOriginalButton.innerHTML = '▶ Play Original Vocoder';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurfer.play();
                    playOriginalButton.innerHTML = '⏸ Pause Original Vocoder';
                    
                    // Update ASR and translation results
                    updateASRResult(outputWaveSurfer.getCurrentTime());
                    updateTranslationResult(outputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playModifiedHandler() {
            // Play/pause only the modified vocoder output
            if (outputWaveSurferModified) {
                if (outputWaveSurferModified.isPlaying()) {
                    outputWaveSurferModified.pause();
                    playModifiedButton.innerHTML = '▶ Play Modified Vocoder';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurferModified.play();
                    playModifiedButton.innerHTML = '⏸ Pause Modified Vocoder';
                    
                    // Update ASR and translation results
                    updateASRResult(outputWaveSurferModified.getCurrentTime());
                    updateTranslationResult(outputWaveSurferModified.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurferModified.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurferModified.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playBothHandler() {
            // Play/pause both output vocoders simultaneously
            if (outputWaveSurfer && outputWaveSurferModified) {
                var isPlaying = outputWaveSurfer.isPlaying() || outputWaveSurferModified.isPlaying();
                
                if (isPlaying) {
                    outputWaveSurfer.pause();
                    outputWaveSurferModified.pause();
                    playBothButton.innerHTML = '▶ Play Both Outputs';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurfer.play();
                    outputWaveSurferModified.play();
                    playBothButton.innerHTML = '⏸ Pause Both Outputs';
                    
                    // Update ASR and translation results (use original vocoder timing)
                    updateASRResult(outputWaveSurfer.getCurrentTime());
                    updateTranslationResult(outputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playSourceOriginalHandler() {
            // Play/pause source audio + original vocoder simultaneously
            if (inputWaveSurfer && outputWaveSurfer) {
                var isPlaying = inputWaveSurfer.isPlaying() || outputWaveSurfer.isPlaying();
                
                if (isPlaying) {
                    inputWaveSurfer.pause();
                    outputWaveSurfer.pause();
                    playSourceOriginalButton.innerHTML = '▶ Play Source + Original';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    // Synchronize both waveforms
                    inputWaveSurfer.play();
                    outputWaveSurfer.play();
                    playSourceOriginalButton.innerHTML = '⏸ Pause Source + Original';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playSourceModifiedHandler() {
            // Play/pause source audio + modified vocoder simultaneously
            if (inputWaveSurfer && outputWaveSurferModified) {
                var isPlaying = inputWaveSurfer.isPlaying() || outputWaveSurferModified.isPlaying();
                
                if (isPlaying) {
                    inputWaveSurfer.pause();
                    outputWaveSurferModified.pause();
                    playSourceModifiedButton.innerHTML = '▶ Play Source + Modified';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    // Synchronize both waveforms
                    inputWaveSurfer.play();
                    outputWaveSurferModified.play();
                    playSourceModifiedButton.innerHTML = '⏸ Pause Source + Modified';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function checkIfStuck(currentTime) {
            // Check if playback time hasn't changed (stuck/finished)
            if (Math.abs(currentTime - lastPlaybackTime) < 0.01) {
                stuckCounter++;
                if (stuckCounter >= 3) {
                    // Audio has been stuck for 3 intervals - force stop
                    console.log("Audio playback stuck at " + currentTime + ", clearing intervals");
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                    stuckCounter = 0;
                    lastPlaybackTime = 0;
                    return true;
                }
            } else {
                stuckCounter = 0;
            }
            lastPlaybackTime = currentTime;
            return false;
        }

        function updateASRResult(currentTime) {
            if (checkIfStuck(currentTime)) return;
            
            fetch(`/asr/${currentTime}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('asrResult').innerText = data.result || '\n'; // Preserve empty line
                });
        }

        function updateTranslationResult(currentTime) {
            fetch(`/translation/${currentTime}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('translationResult').innerText = data.result || '\n'; // Preserve empty line
                });
        }
        function updateLatencyLabel(slider) {
            var latencyValueBox = document.getElementById('latencyValueBox');
            latencyValueBox.innerText = slider.value;
        }

        document.getElementById('uploadForm').addEventListener('change', function() {
            var fileInput = document.getElementById('fileInput');
            var uploadButton = document.getElementById('uploadButton');
            uploadButton.disabled = !fileInput.value;
        });
    </script>
</body>
</html>
