<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamSpeech</title>
    <script src="https://unpkg.com/wavesurfer.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1400px; /* Increased the width */
            margin: 0 auto;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #000000;
        }
        p {
            text-align: center;
        }
        .badges {
            text-align: center;
            margin: 15px 0; /* Reduced the margin */
        }
        form {
            display: flex;
            justify-content: center;
            margin-bottom: 10px; /* Reduced the margin */
        }
        input[type="file"] {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px; /* Reduced the padding */
            cursor: pointer;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px; /* Reduced the padding */
            cursor: pointer;
            margin-left: 10px;
        }
        button:disabled {
            background-color: #ddd;
            cursor: not-allowed;
        }
        button:hover:not([disabled]) {
            background-color: #45a049;
        }
        #playOriginalButton {
            background-color: #ffa500;
            padding: 8px 16px;
        }
        #playOriginalButton:hover:not([disabled]) {
            background-color: #cc8400;
        }
        #playModifiedButton {
            background-color: #800080;
            padding: 8px 16px;
        }
        #playModifiedButton:hover:not([disabled]) {
            background-color: #600060;
        }
        #playBothButton {
            background-color: #70b027;
            padding: 8px 16px;
        }
        #playBothButton:hover:not([disabled]) {
            background-color: #5a8d1f;
        }
        #playSourceOriginalButton {
            background-color: #ffa500;
            padding: 8px 16px;
        }
        #playSourceOriginalButton:hover:not([disabled]) {
            background-color: #cc8400;
        }
        #playSourceModifiedButton {
            background-color: #800080;
            padding: 8px 16px;
        }
        #playSourceModifiedButton:hover:not([disabled]) {
            background-color: #600060;
        }
        #playSourceButton {
            background-color: blue;
            padding: 8px 16px;
        }
        #playSourceButton:hover:not([disabled]) {
            background-color: #0000cc;
        }
        #waveform, #outputWaveform, #outputWaveformModified {
            margin: 10px 0; /* Reduced the margin */
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .results {
            margin-top: 10px; /* Reduced the margin */
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        h2, .result-title {
            font-size: 16px;
            color: #000000;
            align-items: center;
            margin: 5px 0; /* Reduced the margin */
        }
        .result-content {
            font-size: 16px;
            color: #001eff;
            margin-left: 10px;
            white-space: pre-wrap; /* Preserve empty lines */
            min-height: 1em; /* Ensure at least one line of height */
        }
        .result-content2 {
            font-size: 16px;
            color: #ff8800;
            margin-left: 10px;
            white-space: pre-wrap; /* Preserve empty lines */
            min-height: 1em; /* Ensure at least one line of height */
        }
        .streaming-inputs {
            margin-top: 10px; /* Reduced the margin */
            padding: 10px;
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .wave-progress {
            width: 10px; /* Adjust the height for the progress line width */
        }
        .tag-sticker {
        position: absolute;
        font-size: 16px;
        top: 0px; /* Adjusted top position to be above the title */
        left: 5px; /* Adjusted left position to align with the title */
        transform: rotate(-15deg);
        background-color: #ff5722;
        color: white;
        padding: 5px 5px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .title-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0; /* Reduce the margin-bottom to minimize space */
        }
        h1 {
            margin-bottom: -5px; /* Reduced the margin-bottom of the title */
            color: #000000;
        }
        h4{
            font-size: 18px;
            color: #000000;
            margin: 3px 0; /* Reduced the margin */
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-right: 10px;
            position: relative;
        }
        .slider-container label {
            margin-right: 10px;
        }
        #latencySlider {
            margin-right: 10px;
        }
        #latencyValueBox {
            display: inline-block;
            width: 50px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 3px;
            background-color: #fff;
        }
    </style>
    
</head>
<body>
    <div class="container">
        <div class="title-container">
            <div class="tag-sticker"> MODIFIED </div>
            <h1>StreamSpeech: Simultaneous Speech-to-Speech Translation with Multi-task Learning</h1>
        </div>
        <br>
        <form id="uploadForm">
            <div class="slider-container">
                <label for="latencySlider">Latency (ms): </label>
                <input type="range" id="latencySlider" name="latency" min="320" max="5000" value="320" step="10" oninput="updateLatencyLabel(this)">
                <div id="latencyValueBox">320</div>
            </div>
            <input type="file" id="fileInput" name="file" required>
            <button type="submit" id="uploadButton" disabled>Upload</button>
        </form>
        <div class="streaming-inputs">
            <h2>Source Audio (Spanish)</h2>
            <div id="waveform"></div>
            <div style="margin-top: 10px;">
                <button id="playSourceButton" disabled style="background-color: blue; padding: 8px 16px;">‚ñ∂ Play Source</button>
                <button id="playBothButton" disabled style="background-color: #70b027; padding: 8px 16px; margin-left: 10px;">‚ñ∂ Play Both Outputs</button>
                <button id="playSourceOriginalButton" disabled style="background-color: #ffa500; padding: 8px 16px; margin-left: 10px;">‚ñ∂ Play Source + Original</button>
                <button id="playSourceModifiedButton" disabled style="background-color: #800080; padding: 8px 16px; margin-left: 10px;">‚ñ∂ Play Source + Modified</button>
            </div>
        </div>
        <div class="results">
            <h2 class="result-title">Streaming Speech Recognition<br></h2>
            <div id="asrResult" class="result-content"><br></div> <!-- Ensure empty line initially -->
        </div>
        <div class="results">
            <h2 class="result-title">Simultaneous Speech-to-Text Translation</h2>
            <div id="translationResult" class="result-content2"><br></div> <!-- Ensure empty line initially -->
        </div>
        <div class="results">
            <h2 class="result-title">Output: Original Vocoder (Standard English)</h2>
            <div id="outputWaveform"></div>
            <button id="playOriginalButton" disabled style="background-color: #ffa500; margin-top: 10px;">‚ñ∂ Play Original Vocoder</button>
        </div>
        <div class="results" id="modifiedVocoderSection">
            <h2 class="result-title">Output: Modified Vocoder (Voice Transfer - English with Spanish Voice)</h2>
            <div id="outputWaveformModified"></div>
            <button id="playModifiedButton" disabled style="background-color: #800080; margin-top: 10px;">‚ñ∂ Play Modified Vocoder</button>
        </div>
    </div>

    <script>
        // Create AudioContext with explicit 16kHz sample rate to match server output
        // This prevents browser from using default 48kHz which causes 3x speed-up
        var audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000  // CRITICAL: Match the server's SAMPLE_RATE
            });
            console.log('‚úì AudioContext created at ' + audioContext.sampleRate + ' Hz');
        } catch (e) {
            console.error('Failed to create AudioContext with 16kHz:', e);
            // Fallback to default context (may cause speed issues)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.warn('‚ö† Using default AudioContext at ' + audioContext.sampleRate + ' Hz - audio may be sped up');
        }
        
        var inputWaveSurfer, outputWaveSurfer, outputWaveSurferModified;
        var asrInterval, translationInterval;
        var playSourceButton = document.getElementById('playSourceButton');
        var playOriginalButton = document.getElementById('playOriginalButton');
        var playModifiedButton = document.getElementById('playModifiedButton');
        var playBothButton = document.getElementById('playBothButton');
        var playSourceOriginalButton = document.getElementById('playSourceOriginalButton');
        var playSourceModifiedButton = document.getElementById('playSourceModifiedButton');
        var lastPlaybackTime = 0;
        var stuckCounter = 0;

        // Listen for changes in the file input
        document.getElementById('fileInput').addEventListener('change', function() {
            var uploadButton = document.getElementById('uploadButton');
            if (this.files.length > 0) {
                uploadButton.disabled = false;
                uploadButton.style.backgroundColor = '#4CAF50'; // Change color to green
            } else {
                uploadButton.disabled = true;
                uploadButton.style.backgroundColor = '#ddd'; // Change back to gray
            }
        });

        document.getElementById('uploadForm').addEventListener('submit', function(event) {
            event.preventDefault();
            var formData = new FormData();
            var fileInput = document.getElementById('fileInput');
            var file = fileInput.files[0];
            formData.append('file', file);

            // Get the latency value
            var latency = document.getElementById('latencySlider').value;
            console.log('üìä Latency value selected:', latency, 'ms');

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.text())
            .then(filepath => {
                var filename = filepath.split('/').pop();
                refreshResults(); // Refresh results area

                if (inputWaveSurfer) {
                    inputWaveSurfer.destroy();
                }
                if (outputWaveSurfer) {
                    outputWaveSurfer.destroy();
                }
                if (outputWaveSurferModified) {
                    outputWaveSurferModified.destroy();
                }

                inputWaveSurfer = WaveSurfer.create({
                    container: '#waveform',
                    waveColor: '#ffffff',
                    progressColor: 'blue',
                    normalize: true,
                    progressClass: 'wave-progress',
                    interact: false,  // Disable seeking by clicking
                    loop: false,      // Disable looping
                    audioContext: audioContext  // Use 16kHz context
                });

                inputWaveSurfer.on('ready', function() {
                    // Check if dual mode is enabled
                    fetch('/is_dual_mode')
                        .then(response => response.json())
                        .then(data => {
                            const isDualMode = data.dual_mode;
                            
                            // Create original output WaveSurfer
                            outputWaveSurfer = WaveSurfer.create({
                                container: '#outputWaveform',
                                waveColor: '#f9f9f9',
                                progressColor: 'orange',
                                normalize: true,
                                loop: false,  // Disable looping
                                audioContext: audioContext  // Use 16kHz context
                            });

                            if (isDualMode) {
                                // DUAL MODE: Load both outputs
                                console.log("Dual mode detected - loading both vocoders");
                                
                                // Update title for original output
                                document.querySelector('.results:nth-of-type(3) .result-title').innerText = 
                                    'Simultaneous Speech-to-Speech Translation (Original Vocoder)';
                                
                                // Load original vocoder output
                                outputWaveSurfer.load(`/output_original/${filename}`);
                                
                                // Create Modified Vocoder output WaveSurfer
                                outputWaveSurferModified = WaveSurfer.create({
                                    container: '#outputWaveformModified',
                                    waveColor: '#f9f9f9',
                                    progressColor: 'purple',
                                    normalize: true,
                                    loop: false,  // Disable looping
                                    audioContext: audioContext  // Use 16kHz context
                                });
                                
                                // Load modified vocoder output
                                outputWaveSurferModified.load(`/output_modified/${filename}`);
                                
                                playModifiedButton.disabled = false;
                                playModifiedButton.style.backgroundColor = '#800080';
                            } else {
                                // SINGLE MODE: Load only one output
                                console.log("Single mode - loading default vocoder");
                                
                                // Load default output
                                outputWaveSurfer.load(`/output/${filename}`);
                                
                                playModifiedButton.disabled = true;
                                playModifiedButton.style.backgroundColor = '#ddd';
                            }

                            playSourceButton.disabled = false;
                            playSourceButton.style.backgroundColor = 'blue';
                            
                            playOriginalButton.disabled = false;
                            playOriginalButton.style.backgroundColor = '#ffa500';
                            
                            playSourceOriginalButton.disabled = false;
                            playSourceOriginalButton.style.backgroundColor = '#ffa500';

                            // Ensure old event listeners are removed before adding new ones
                            playSourceButton.removeEventListener('click', playSourceHandler);
                            playSourceButton.addEventListener('click', playSourceHandler);
                            
                            playOriginalButton.removeEventListener('click', playOriginalHandler);
                            playOriginalButton.addEventListener('click', playOriginalHandler);
                            
                            playSourceOriginalButton.removeEventListener('click', playSourceOriginalHandler);
                            playSourceOriginalButton.addEventListener('click', playSourceOriginalHandler);
                            
                            if (isDualMode) {
                                playModifiedButton.removeEventListener('click', playModifiedHandler);
                                playModifiedButton.addEventListener('click', playModifiedHandler);
                                
                                playBothButton.disabled = false;
                                playBothButton.style.backgroundColor = '#70b027';
                                playBothButton.removeEventListener('click', playBothHandler);
                                playBothButton.addEventListener('click', playBothHandler);
                                
                                playSourceModifiedButton.disabled = false;
                                playSourceModifiedButton.style.backgroundColor = '#800080';
                                playSourceModifiedButton.removeEventListener('click', playSourceModifiedHandler);
                                playSourceModifiedButton.addEventListener('click', playSourceModifiedHandler);
                            }
                            
                            // Add finish and pause event handlers INSIDE the async callback
                            // This ensures WaveSurfer instances are fully created
                            outputWaveSurfer.on('finish', function() {
                                console.log("Original output finished");
                                // Reset ALL button states that might be using this audio
                                playOriginalButton.innerHTML = '‚ñ∂ Play Original Vocoder';
                                playBothButton.innerHTML = '‚ñ∂ Play Both Outputs';
                                playSourceOriginalButton.innerHTML = '‚ñ∂ Play Source + Original';
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });
                            
                            outputWaveSurfer.on('pause', function() {
                                console.log("Original output paused");
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });
                            
                            if (isDualMode && outputWaveSurferModified) {
                                outputWaveSurferModified.on('finish', function() {
                                    console.log("Modified output finished");
                                    // Reset ALL button states that might be using this audio
                                    playModifiedButton.innerHTML = '‚ñ∂ Play Modified Vocoder';
                                    playBothButton.innerHTML = '‚ñ∂ Play Both Outputs';
                                    playSourceModifiedButton.innerHTML = '‚ñ∂ Play Source + Modified';
                                    clearInterval(asrInterval);
                                    clearInterval(translationInterval);
                                    asrInterval = null;
                                    translationInterval = null;
                                });
                                
                                outputWaveSurferModified.on('pause', function() {
                                    console.log("Modified output paused");
                                    clearInterval(asrInterval);
                                    clearInterval(translationInterval);
                                    asrInterval = null;
                                    translationInterval = null;
                                });
                            }
                            
                            inputWaveSurfer.on('pause', function() {
                                console.log("Input paused");
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });
                            
                            inputWaveSurfer.on('finish', function() {
                                console.log("Input finished");
                                // Reset ALL button states that might be using this audio
                                playSourceButton.innerHTML = '‚ñ∂ Play Source';
                                playSourceOriginalButton.innerHTML = '‚ñ∂ Play Source + Original';
                                playSourceModifiedButton.innerHTML = '‚ñ∂ Play Source + Modified';
                                clearInterval(asrInterval);
                                clearInterval(translationInterval);
                                asrInterval = null;
                                translationInterval = null;
                            });
                        });
                });

                // Pass the latency parameter to the server
                console.log('üåê Requesting processing with URL:', `/process/${filename}?latency=${latency}`);
                inputWaveSurfer.load(`/process/${filename}?latency=${latency}`);
            })
            .catch(error => console.error('Error:', error));
        });

        function refreshResults() {
            document.getElementById('asrResult').innerText = ''; // Clear ASR result and preserve empty line
            document.getElementById('translationResult').innerText = ''; // Clear translation result and preserve empty line
            document.getElementById('outputWaveform').innerHTML = ''; // Clear output waveform
            document.getElementById('outputWaveformModified').innerHTML = ''; // Clear Modified Vocoder output waveform
            document.getElementById('waveform').innerHTML = ''; // Clear input waveform
            if (inputWaveSurfer) {
                inputWaveSurfer.destroy();
                inputWaveSurfer = null;
            }
            if (outputWaveSurfer) {
                outputWaveSurfer.destroy();
                outputWaveSurfer = null;
            }
            if (outputWaveSurferModified) {
                outputWaveSurferModified.destroy();
                outputWaveSurferModified = null;
            }
        }

        function playSourceHandler() {
            // Play/pause only the source audio
            if (inputWaveSurfer) {
                if (inputWaveSurfer.isPlaying()) {
                    inputWaveSurfer.pause();
                    playSourceButton.innerHTML = '‚ñ∂ Play Source';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    inputWaveSurfer.play();
                    playSourceButton.innerHTML = '‚è∏ Pause Source';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playOriginalHandler() {
            // Play/pause only the original vocoder output
            if (outputWaveSurfer) {
                if (outputWaveSurfer.isPlaying()) {
                    outputWaveSurfer.pause();
                    playOriginalButton.innerHTML = '‚ñ∂ Play Original Vocoder';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurfer.play();
                    playOriginalButton.innerHTML = '‚è∏ Pause Original Vocoder';
                    
                    // Update ASR and translation results
                    updateASRResult(outputWaveSurfer.getCurrentTime());
                    updateTranslationResult(outputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playModifiedHandler() {
            // Play/pause only the modified vocoder output
            if (outputWaveSurferModified) {
                if (outputWaveSurferModified.isPlaying()) {
                    outputWaveSurferModified.pause();
                    playModifiedButton.innerHTML = '‚ñ∂ Play Modified Vocoder';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurferModified.play();
                    playModifiedButton.innerHTML = '‚è∏ Pause Modified Vocoder';
                    
                    // Update ASR and translation results
                    updateASRResult(outputWaveSurferModified.getCurrentTime());
                    updateTranslationResult(outputWaveSurferModified.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurferModified.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurferModified.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playBothHandler() {
            // Play/pause both output vocoders simultaneously
            if (outputWaveSurfer && outputWaveSurferModified) {
                var isPlaying = outputWaveSurfer.isPlaying() || outputWaveSurferModified.isPlaying();
                
                if (isPlaying) {
                    outputWaveSurfer.pause();
                    outputWaveSurferModified.pause();
                    playBothButton.innerHTML = '‚ñ∂ Play Both Outputs';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    outputWaveSurfer.play();
                    outputWaveSurferModified.play();
                    playBothButton.innerHTML = '‚è∏ Pause Both Outputs';
                    
                    // Update ASR and translation results (use original vocoder timing)
                    updateASRResult(outputWaveSurfer.getCurrentTime());
                    updateTranslationResult(outputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(outputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playSourceOriginalHandler() {
            // Play/pause source audio + original vocoder simultaneously
            if (inputWaveSurfer && outputWaveSurfer) {
                var isPlaying = inputWaveSurfer.isPlaying() || outputWaveSurfer.isPlaying();
                
                if (isPlaying) {
                    inputWaveSurfer.pause();
                    outputWaveSurfer.pause();
                    playSourceOriginalButton.innerHTML = '‚ñ∂ Play Source + Original';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    // Synchronize both waveforms
                    inputWaveSurfer.play();
                    outputWaveSurfer.play();
                    playSourceOriginalButton.innerHTML = '‚è∏ Pause Source + Original';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function playSourceModifiedHandler() {
            // Play/pause source audio + modified vocoder simultaneously
            if (inputWaveSurfer && outputWaveSurferModified) {
                var isPlaying = inputWaveSurfer.isPlaying() || outputWaveSurferModified.isPlaying();
                
                if (isPlaying) {
                    inputWaveSurfer.pause();
                    outputWaveSurferModified.pause();
                    playSourceModifiedButton.innerHTML = '‚ñ∂ Play Source + Modified';
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                } else {
                    // Clear any existing intervals first
                    if (asrInterval) clearInterval(asrInterval);
                    if (translationInterval) clearInterval(translationInterval);
                    
                    // Synchronize both waveforms
                    inputWaveSurfer.play();
                    outputWaveSurferModified.play();
                    playSourceModifiedButton.innerHTML = '‚è∏ Pause Source + Modified';
                    
                    // Update ASR and translation results
                    updateASRResult(inputWaveSurfer.getCurrentTime());
                    updateTranslationResult(inputWaveSurfer.getCurrentTime());

                    asrInterval = setInterval(function() {
                        updateASRResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam

                    translationInterval = setInterval(function() {
                        updateTranslationResult(inputWaveSurfer.getCurrentTime());
                    }, 1000);  // Update every 1 second to reduce terminal spam
                }
            }
        }

        function checkIfStuck(currentTime) {
            // Check if playback time hasn't changed (stuck/finished)
            if (Math.abs(currentTime - lastPlaybackTime) < 0.01) {
                stuckCounter++;
                if (stuckCounter >= 3) {
                    // Audio has been stuck for 3 intervals - force stop
                    console.log("Audio playback stuck at " + currentTime + ", clearing intervals");
                    clearInterval(asrInterval);
                    clearInterval(translationInterval);
                    asrInterval = null;
                    translationInterval = null;
                    stuckCounter = 0;
                    lastPlaybackTime = 0;
                    return true;
                }
            } else {
                stuckCounter = 0;
            }
            lastPlaybackTime = currentTime;
            return false;
        }

        function updateASRResult(currentTime) {
            if (checkIfStuck(currentTime)) return;
            
            fetch(`/asr/${currentTime}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('asrResult').innerText = data.result || '\n'; // Preserve empty line
                });
        }

        function updateTranslationResult(currentTime) {
            fetch(`/translation/${currentTime}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('translationResult').innerText = data.result || '\n'; // Preserve empty line
                });
        }
        function updateLatencyLabel(slider) {
            var latencyValueBox = document.getElementById('latencyValueBox');
            latencyValueBox.innerText = slider.value;
        }

        document.getElementById('uploadForm').addEventListener('change', function() {
            var fileInput = document.getElementById('fileInput');
            var uploadButton = document.getElementById('uploadButton');
            uploadButton.disabled = !fileInput.value;
        });
    </script>
</body>
</html>
